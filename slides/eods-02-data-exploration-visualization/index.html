<!DOCTYPE html>
<html>
  <head>
    <title>Data Exploration and Visualization</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Garamond);
      @import url(https://fonts.googleapis.com/css?family=Muli:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
    </style>
    <link rel="stylesheet" href="../style.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle

Elements of Data Science - F2019

# Data Exploration and Visualization

09/16/2019

---
# TODOs
<br/>

--
count: false
- Reading: Parts of Ch 2,3,4

--
count: false
- Answer and submit Quiz2


---
# PDSH Ch 2,3,4

.smaller[
- Ch 2. Introduction to NumPy
    - Understanding Data Types in Python
    - The Basics of NumPy Arrays
    - <span style="color:gray;">Computation on NumPy Arrays: Universal Functions</span>
    - Aggregations: Min, Max, and Everything In Between
    - <span style="color:gray;">Computation on Arrays: Broadcasting</span>
    - Comparisons, Masks, and Boolean Logic
    - <span style="color:gray;">Fancy Indexing</span>
    - Sorting Arrays
    - <span style="color:gray;">Structured Data: NumPy's Structured Arrays</span>
]

---
# PDSH Ch 2,3,4

.smaller[
- Ch 3. Data Manipulation with Pandas
    - Introducing Pandas Objects
    - Data Indexing and Selection
    - <span style="color:gray;">Operating on Data in Pandas</span>
    - Handling Missing Data
    - <span style="color:gray;">Hierarchical Indexing</span>
    - <span style="color:gray;">Combining Datasets: Concat and Append</span>
    - <span style="color:gray;">Combining Datasets: Merge and Join</span>
    - <span style="color:gray;">Aggregation and Grouping</span>
    - <span style="color:gray;">Pivot Tables</span>
    - <span style="color:gray;">Vectorized String Operations</span>
    - <span style="color:gray;">Working with Time Series</span>
    - <span style="color:gray;">High-Performance Pandas: eval() and query()</span>
]

---
# PDSH Ch 2,3,4
.smaller[
- Ch 4. Visualization with Matplotlib
    - Simple Line Plots
    - Simple Scatter Plots
    - <span style="color:gray;">Visualizing Errors</span>
    - <span style="color:gray;">Density and Contour Plots</span>
    - <span style="color:gray;">Histograms, Binnings, and Density</span>
    - <span style="color:gray;">Customizing Plot Legends</span>
    - <span style="color:gray;">Customizing Colorbars</span>
    - Multiple Subplots
    - <span style="color:gray;">Text and Annotation</span>
    - <span style="color:gray;">Customizing Ticks</span>
    - <span style="color:gray;">Customizing Matplotlib: Configurations and Stylesheets</span>
    - Three-Dimensional Plotting in Matplotlib
    - <span style="color:gray;">Geographic Data with Basemap</span>
    - Visualization with Seaborn
]


---
# Getting Changes from Git

```
$ cd [to_repository]
$ git pull
```


---
# Today's Agenda

--
count:false

- Python Review

--
count:false

- Intro to NumPy

--
count:false

- Intro to Pandas

--
count:false

- Data Exploration with Pandas

--
count:false

- Intro to Visualization in Python


---
# Python Review


--
count:false
- Basic Data Types


--
count:false
- Comparisons and Logical Operators


--
count:false
- Conditionals


--
count:false
- Looping


--
count:false
- List/Dict Comprehensions


<br/>
--
count:false
- Style Guide : PEP 8 (https://www.python.org/dev/peps/pep-0008/)


---
#Basic Python Data Types
<br/>

--
count:false
- **int** : `42`

--
count:false
- **float** : `4.2` or `4e2`

--
count:false
- **boolean (bool)** : `True` or `False`

--
count:false
- **string (str)** : `'num 42'` or `"num 42"`

--
count:false
- **none**: `None`

<br/>
--
count:false
- also `long`, `complex`, `bytes`, etc.

---
#Python Data Types Continued

--
count:false
- **list** : `x = [42,'e',2.0]`&nbsp;&nbsp;
--
count:false
    - `x[0] == 42 # indexing`
--
count:false
    - `x[2] = 4 # assignment`
--
count:false
    - `x.pop(2) # delete`


--
count:false
- **dict** : `x = {'b':2,'a':1,'c':4}`
--
count:false
    - `x['b'] == 2 # indexing`
--
count:false
    - `x['d'] = 3 # assignment`
--
count:false
    - `x.pop('d',None) # delete`
--
count:false
    - `x.keys()`
--
count:false
    - `x.values()`
--
count:false
    - `x.items()`

---
#Python Data Types Continued
<br>

--
count:false
- **tuple** : `x = (2,'e')`
--
count:false
    - `x[0] == 2 # indexing`
--
count:false
    - `x[0] = 3 # assignment? Nope, error, immutable`

--
count:false
- **set** : `x = {2,'e','e'}`
--
count:false
    - `x.add(1)`
--
count:false
    - `x.remove('e')`
--
count:false
    - `x.intersection({2,3})`
--
count:false
    - `x.difference({2,3})`


---
# Python Comparisons and Logical Operators
<br/>


--
count:false
- `==, !=, &lt;, &gt;, &lt;=, &gt;=`


--
count:false
- `is, and, or, not`

<br/>
--
count:false
bitwise operators, we'll see these in numpy and pandas
- `&amp;, | , ~` 


---
# Control Flow

--
count:false
- if then elif then else

```python
>>> if x &gt; 0:
...     print('x &gt; 0')
... elif x &lt; 0:
...     print('x &lt; 0')
... else:
...     print('x == 0')
```

--
count:false

- single line if then else

```python
>>> "x &lt; 0" if (x &lt; 0) else "x &gt;= 0"
```

---
# More Control Flow

--
count:false
- for loop

```python
>>> for x in [0,1,2,3,4]:
...     print(x)
```

--
count:false
- while loop

```python
>>> x = 0
... while x &lt; 5:
...     print(x)
...     x += 1
```

---
# More Control Flow

--
count:false
- `break` : break out of current loop

```python
>>> x = 0
... while True:
...     print(x)
...     x += 1
...     if x == 5:
...         break
```

--
count:false
- `continue` : continue immediately to next iteration of loop

```python
>>> for x in range(5):
...     if x == 1:
...         continue
...     print(x)
```

---
# Useful Functions

--
count:false
```python
>>> len([0,1,2,3]) # get number of items in container
4
```

--
count:false
- range

```python
>>> list(range(3))
[0, 1, 2]
```

--
count:false
```python
>>> list(range(2,5,2))
[2, 4]
```


--
count:false
- enumerate

```python
>>> list(enumerate(['a','b','c']))
[(0, 'a'), (1, 'b'), (2, 'c')]
```

---
# `collections` Library

--
count:false
- Counter : useful for counting hashable objects

```python
>>> cnt = Counter()
>>> for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:
...     cnt[word] += 1
>>> cnt
Counter({'blue': 3, 'red': 2, 'green': 1})
```


--
count:false
- OrderedDict : remembers order added


--
count:false
- defaultdict : supplies missing values


--
count:false
- others : https://docs.python.org/3.7/library/collections.html

---
# List/Dict Comprehensions

--
count:false
- List Comprehension

```python
>>> y = range(1,6) # [1,2,3,4,5]
>>> [x%2 for x in y]
[1, 0, 1, 0, 1]
```
--
count:false
```python
>>> [i for i,x in enumerate(y) if x%2 == 0]
[1, 3]
```

--
count:false
- Dict Comprehension

```python
>>> pairs = ((1,'e'),(3,'f'))
>>> x = {key:'value_'+val for key,val in pairs}
>>> x
{1: 'value_e', 3: 'value_f'}
```

---
class:middle

# Questions re Python?

---
#Working with Data
<br/>

Want to:
--
count:false

--
count:false
- transform and select data quickly (numpy)


--
count:false
- manipulate datasets: load,save,group,join,etc. (pandas)


--
count:false
- keep things organized (pandas)





---
# Intro to NumPy

.center[
![:scale 25%](images/NumPy_logo.svg)]

--
count:false
 Provides (from numpy.org):

--
count:false
 - a powerful N-dimensional array object


--
count:false
 - sophisticated (broadcasting) functions


--
count:false
 - linear algebra and random number capabilities


--
count:false
- (Fourier transform, tools for integrating C/C++ and Fortran code, etc.)


---
#Python Dynamic Typing

--
count:false
```python
>>> for x in my_iterable:
...     print(x)
```
--
count:false
```python
>>> x = 5
>>> x = 'five'
```
--
count:false
- Note: still *strongly* typed

```python
>>> x,y = 5,'five'
>>> x+y
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'int' and 'str'

```

---
#Python Dynamic Typing
<br/>


--
count:false

<br/>
.middle.center[
![](images/cint_vs_pyint.png)]
<br/>
<br/>
.small.bottom[[PDHS Chap 2.](https://jakevdp.github.io/PythonDataScienceHandbook/02.01-understanding-data-types.html)]



---
#NumPy Array vs Python List:

--
count:false

<br/>
.middle.center[
![:scale 75%](images/array_vs_list.png)]
<br>
.bottom.small[[PDHS Chap 2.](https://jakevdp.github.io/PythonDataScienceHandbook/02.01-understanding-data-types.html)]


---
#Importing NumPy
<br>

--
count:false
Using the alias `np`

```python
>>> import numpy as np
```

---
#NumPy Datatypes
.smaller[
```
bool_       Boolean (True or False) stored as a byte
int_        Default integer type (same as C long; normally either int64 or int32)
intc        Identical to C int (normally int32 or int64)
intp        Integer used for indexing (same as C ssize_t; normally either int32 or int64)
int8        Byte (-128 to 127)
int16       Integer (-32768 to 32767)
int32       Integer (-2147483648 to 2147483647)
int64       Integer (-9223372036854775808 to 9223372036854775807)
uint8       Unsigned integer (0 to 255)
uint16      Unsigned integer (0 to 65535)
uint32      Unsigned integer (0 to 4294967295)
uint64      Unsigned integer (0 to 18446744073709551615)
float_      Shorthand for float64.
float16     Half precision float: sign bit, 5 bits exponent, 10 bits mantissa
float32     Single precision float: sign bit, 8 bits exponent, 23 bits mantissa
float64     Double precision float: sign bit, 11 bits exponent, 52 bits mantissa
complex_	Shorthand for complex128.
complex64   Complex number, represented by two 32-bit floats
complex128  Complex number, represented by two 64-bit floats
...
```
]

---
#NumPy Arrays

--
count:false
```python
>>> np.array([1,2,3])
array([1, 2, 3])
```

--
count:false
```python
>>> np.array([1,'two',3])
array(['1', 'two', '3'], dtype='&lt;U21')
```

--
count:false
```ipython
>>> np.ones(5,dtype=int)
array([1, 1, 1, 1, 1])
```

--
count:false
```python
>>> np.full((2,3),3.14)
array([[3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14]])
```

---
#NumPy Array Indexing

--
count:false
```python
>>> x = np.arange(1,6)
>>> x
array([1, 2, 3, 4, 5])
```

--
count:false
```python
>>> x[0]
1
```

--
count:false
```python
>>> x[-1]
5
```

--
count:false
```python
>>> x[-2]
4
```


---
#NumPy Array Slicing

--
count:false
```python
>>> x
array([1, 2, 3, 4, 5])
```

--
count:false
```python
>>> x[:2]
array([1, 2])
```

--
count:false
```python
>>> x[3:]
array([4, 5])
```

--
count:false
```python
>>> x[-3:]
array([3, 4, 5])
```

--
count:false
```python
>>> x[1:3]
array([2, 3])
```

---
#NumPy Array Slicing with Steps

--
count:false
```python
>>> x
array([1, 2, 3, 4, 5])
```

--
count:false
```python
>>> x[1:4:2]
array([2, 4])
```

--
count:false

```python
>>> x[::-1]
array([5, 4, 3, 2, 1])
```

---
#NumPy Fancy Indexing

--
count:false
Accessing multiple indexes at once

--
count:false
```python
>>> x = np.array([5,6,7,8])
```

--
count:false
```python
>>> x[[0,3]]
array([5, 8])
```

--
count:false
```python
>>> x[[0,-1]]
array([5, 8])
```

---
#Boolean Indexing

--
count:false
```python
>>> x = np.array([5,6,7,8])
```

--
count:false
```python
>>> x%2 == 0
array([False,  True, False,  True])
```

--
count:false
```python
>>> x[x%2 == 0]
array([6, 8])
```

--
count:false
```python
>>> x[x > 6]
array([7, 8])
```

---
#Bool Indexing And Bitwise Operators

--
count:false
```python
>>> (x%2 == 0)
array([False,  True, False,  True])
```

--
count:false
```python
>>> (x > 6)
array([False, False,  True,  True])
```

--
count:false
```python
>>> (x%2 == 0) & (x > 6)
array([False, False, False,  True])

```

--
count:false
```python
>>> x[(x%2 == 0) & (x > 6)]
array([8])
```

---
#Bool Indexing And Bitwise Operators

--
count:false
and : &amp;

```python
>>> x[(x%2 == 0) & (x > 6)]
array([8])
```

--
count:false
or : |

```python
>>> x[(x%2 == 0) | (x > 6)]
array([6, 7, 8])
```

--
count:false
not : ~

```python
>>> x[~( (x%2 == 0) | (x > 6) )]
array([5])
```

---
# `&amp;`,`|` vs. `and`,`or`

--
count:false
- `&amp;`, `|`, `~` operate on bits
- Think arrays of 'True', 'False'
- Operate element-wise


--
count:false
- `and`, `or`, `not` operate on objects
- Think single Boolean object
- Evaluate entire object


--
count:false
- see PDHS for more info


---
#Indexing Review

--
count:false
- standard array (including reverse/negative)

--
count:false
- slicing

--
count:false
- fancy indexing

--
count:false
- boolean indexing

---
#Multidimensional Lists

--
count:false
```python
>>> x = [[1,2,3],[4,5,6]] # list of lists
>>> x
[[1, 2, 3], [4, 5, 6]]
```
--
count:false
```python
>>> x[0][0] # first row, first column
1
```
--
count:false
```python
>>> x[0] # first row
[1, 2, 3]
```
--
count:false
```python
>>> [row[0] for row in x] # first column?
[1, 4]
```

---
#NumPy Multidimensional Arrays
--
count:false
```python
>>> x = np.array([[1,2,3],[4,5,6]])
>>> x
array([[1, 2, 3],
       [4, 5, 6]])
```
--
count:false
```python
>>> x[0,0] # first row, first column
1
```
--
count:false
```python
>>> x[0,:] # first row
array([1, 2, 3])
```
--
count:false
```python
>>> x[:,0] # first column
array([1, 4])
```


---
#NumPy Array Attributes

--
count:false
```python
>>> x = np.array([[1,2,3],[4,5,6]])
```
--
count:false
```python
*>>> x.ndim # number of dimensions
2
```

--
count:false
```python
*>>> x.shape # shape in each dimension
(2,3)
```

--
count:false
```python
*>>> x.size # size over all dimensions
6
```

---
#NumPy Operations (UFuncs)

--
count:false
```python
>>> x = [1,2,3]
>>> y = [4,5,6]
```
--
count:false
```python
*>>> x+y
[1, 2, 3, 4, 5, 6]
```
<br>
--
count:false
```python
>>> x = np.array([1,2,3])
>>> y = np.array([4,5,6])
```
--
count:false
```python
*>>> x+y
array([5, 7, 9])
```


---
#NumPy Broadcasting

Allows for vectorized computation on arrays of different sizes

--
count:false
```python
>>> x = [1,2,3]
>>> z = 2
*>>> x**2
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'

```
--
count:false
```python
>>> x = np.array([1,2,3])
>>> z = 2
*>>> x**2
array([1, 4, 9])
```

---
#NumPy `random` Submodule

Provides many random sampling functions

--
count:false
`from numpy.random import ...`

--
count:false
- `rand` : random floats

--
count:false
- `randint` : random integers

--
count:false
- `randn` : standard normal distribution

--
count:false
- `permutation` : random permutation

--
count:false
- `normal` : Gaussian normal distribution


--
count:false
- `seed` : seed the random generator


---
#Intro to Pandas
<br/>

.center[
![](images/pandas_logo.png)]

--
count:false
pandas is an open source, BSD-licensed library providing:

--
count:false
- **high-performance, easy-to-use data structures** and 

--
count:false
- **data analysis tools**

<br/>
--
count:false
Importing Pandas:

```python
import pandas as pd
```

---
#Pandas Series


- 1D array of data (any numpy datatype) plus an associated **index** array

--
count:false

```python
>>> s = pd.Series(np.random.rand(4))
>>> s
0    0.641947
1    0.327688
2    0.907652
3    0.072368
dtype: float64
```

--
count:false
```python
>>> s.values
array([0.64194677, 0.32768794, 0.90765227, 0.07236816])
```
--
count:false
```python
>>> s.index
RangeIndex(start=0, stop=4, step=1)
```

---
#Pandas Series Cont.

--
count:false
```python
>>> s = pd.Series(np.random.rand(4),index=['a','b','c','d'])
>>> s
a    0.630579
b    0.265923
c    0.756642
d    0.930738
dtype: float64
```

--
count:false
```python
>>> s['a']
0.6305786049043965
```

--
count:false
```python
>>> s[['c','d']]
c    0.756642
d    0.930738
dtype: float64
```


---
#Pandas Series Cont.

--
count:false
```python
>>> s = pd.Series({'a':1,'b':2,'c':3,'d':4})
>>> s
a    1
b    2
c    3
d    4
dtype: int64
```

--
count:false
```python
>>> s[s.index[-2:]]
c    3
d    4
dtype: int64
```

---
#Pandas DataFrame
</br>

--
count:false
- tabular datastructure
--
count:false
- each column a single datatype
--
count:false
- both row and column indices
--
count:false
- single column == Series


---
#Pandas DataFrame Cont.

--
count:false

```python
>>> df = pd.DataFrame({'Year':[2017,2018,2018,2019],
...                    'Class_Name':['A','A','B','A'],
...                    'Measure1':[2.1,3.0,2.4,1.9]
...                   })
```

--
count:false

```python
>>> df
   Year Class_Name  Measure1
0  2017          A       2.1
1  2018          A       3.0
2  2018          B       2.4
3  2019          A       1.9

```

---
#Pandas DataFrame Cont.

```python
>>> data = [[2017,'A',2.1],
...         [2018,'A',3.0],
...         [2018,'B',2.4],
...         [2019,'A',1.9]]
```

--
count:false

```python
>>> df = pd.DataFrame(data,
...                   columns=['Year','Class_Name','Measure1'],
...                   index=['001','002','003','004'])
```

--
count:false

```python
>>> df
     Year Class_Name  Measure1
001  2017          A       2.1
002  2018          A       3.0
003  2018          B       2.4
004  2019          A       1.9

```

---
#Pandas Attributes

--
count:false

- Get shape of DataFrame : `shape`

```python
>>> df.shape
(4, 3) # rows, columns
```

--
count:false
- Get index values : `index`

```python
>>> df.index
Index(['001', '002', '003', '004'], dtype='object')
```

--
count:false

- Get column values : `columns`

```python
>>> df.columns
Index(['Year', 'Class_Name', 'MeasureA'], dtype='object')
```

---
#Pandas Indexing/Selection
<br/>


--
count:false
Select by label:
- `.loc[]`

--
count:false

```python
>>> df.loc['001']
Year          2017
Class_Name       A
MeasureA       2.1
Name: 001, dtype: object

```
--
count:false

```python
>>> df.loc['001','MeasureA']
2.1
```

---
#Pandas Indexing/Selection Cont.
<br/>

--
count:false
Select by index:
- `.iloc[]`
--
count:false

```python
>>> df.iloc[0]
Year          2017
Class_Name       A
MeasureA       2.1
Name: 001, dtype: object

```
--
count:false
```python
>>> df.iloc[0,2]
2.1
```

---
#Pandas Indexing/Selection Cont.

--
count:false
Selecting multiple rows/columns: use list (fancy indexing)
--
count:false

```python
>>> df.loc[['002','004']]
     Year Class_Name  MeasureA
002  2018          A       3.0
004  2019          A       1.9
```

--
count:false

```python
>>> df.loc[['002','004'],['Year','MeasureA']]
     Year  MeasureA
002  2018       3.0
004  2019       1.9
```


---
#Pandas Slicing

--
count:false
Get last two rows
--
count:false
```python
>>> df.iloc[-2:]
     Year Class_Name  MeasureA
003  2018          B       2.4
004  2019          A       1.9
```

--
count:false
Get first two rows and first two columns
--
count:false

```python
>>> df.iloc[:2,:2]
     Year Class_Name
001  2017          A
002  2018          A
```

---
#Pandas Slicing Cont.

--
count:false
Can also slice using labels:
--
count:false
```python
>>> df.loc['002':'004']
     Year Class_Name  MeasureA
002  2018          A       3.0
003  2018          B       2.4
004  2019          A       1.9
```

--
count:false

```python
>>> df.loc['002':'004',:'Class_Name']
     Year Class_Name
002  2018          A
003  2018          B
004  2019          A

```

--
count:false
**NOTE: this is inclusive**

---
#Pandas Slicing Cont.

How to indicate all rows or all columns? `:`

--
count:false

```python
>>> df.loc[:,'MeasureA']
001    2.1
002    3.0
003    2.4
004    1.9
Name: MeasureA, dtype: float64
```

--
count:false
```python
>>> df.iloc[2:,:]
     Year Class_Name  MeasureA
003  2018          B       2.4
004  2019          A       1.9
```

---
#Pandas Slicing Cont.

--
count:false

Shortcut for columns:

--
count:false

```python
>>> df['MeasureA']
001    2.1
002    3.0
003    2.4
004    1.9
Name: MeasureA, dtype: float64
```

--
count:false

```python
>>> df[['Year','MeasureA']]
     Year  MeasureA
001  2017       2.1
002  2018       3.0
003  2018       2.4
004  2019       1.9
```


---
#Pandas Slicing Cont.

--
count:false

Shortcut for columns:
--
count:false
```python
>>> df.Class_Name
001    A
002    A
003    B
004    A
Name: Class_Name, dtype: object
```

--
count:false

Shortcut for columns + series:
--
count:false

```python
>>> df.Class_Name['001']
'A'
```

---
#Pandas Boolean Mask

--
count:false
Get all records for Class_Name 'A'
--
count:false

```python
>>> df.loc[df.Class_Name == 'A']:
     Year Class_Name  MeasureA
001  2017          A       2.1
002  2018          A       3.0
004  2019          A       1.9

```
--
count:false

Get MeasureA for all records for Class_Name 'A':

--
count:false

```python
>>> df.loc[df.Class_Name == 'A','MeasureA']
001    2.1
002    3.0
004    1.9
Name: MeasureA, dtype: float64
```

---
#Pandas Boolean Mask Cont.

--
count:false

Get all records for class 'A' before 2019:

--
count:false

```python
>>> df.loc[(df.Class_Name == 'A') &amp; (df.Year &lt; 2019)]
     Year Class_Name  MeasureA
001  2017          A       2.1
002  2018          A       3.0
```

--
count:false

Get all records in a set of years:

--
count:false

```python
>>> df.loc[df.Year.isin([2017,2019])]
     Year Class_Name  MeasureA
001  2017          A       2.1
004  2019          A       1.9
```

---
# Panda Selection Chaining

--
count:false
Get 'Year' and 'MeasureA' for first 3 rows:

--
count:false

```python
>>> df.iloc[:3].loc[:,['Year','MeasureA']]
     Year  MeasureA
001  2017       2.1
002  2018       3.0
003  2018       2.4
```

--
count:false

For records '001' and '003' get last two columns:

--
count:false

```python
>>> df.loc[['001','003']].iloc[:,-2:]
    Class_Name  MeasureA
001          A       2.1
003          B       2.4
```


---
# Panda Selection Chaining Cont.

--
count:false

For record '001' get last two columns?:

--
count:false

```python
>>> df.loc['001'].iloc[:,-2:]
```

--
count:false


```python
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/bgibson/anaconda3/envs/eods-f19/lib/python3.7/site-packages/pandas/core/indexing.py", line 1418, in __getitem__
    return self._getitem_tuple(key)
  File "/home/bgibson/anaconda3/envs/eods-f19/lib/python3.7/site-packages/pandas/core/indexing.py", line 2092, in _getitem_tuple
    self._has_valid_tuple(tup)
  File "/home/bgibson/anaconda3/envs/eods-f19/lib/python3.7/site-packages/pandas/core/indexing.py", line 233, in _has_valid_tuple
    raise IndexingError("Too many indexers")
pandas.core.indexing.IndexingError: Too many indexers
```

--
count:false

```python
>>> df.loc['001'].iloc[-2:] 
```


---
# Pandas `head` and `tail`

--
count:false

Get a quick view of the first or last rows in a DataFrame

--
count:false

```python
>>> df.head() # first 5 rows by default
     Year Class_Name  MeasureA
001  2017          A       2.1
002  2018          A       3.0
003  2018          B       2.4
004  2019          A       1.9
```

--
count:false

```python
>>> df.tail(2)
     Year Class_Name  MeasureA
003  2018          B       2.4
004  2019          A       1.9
```

---
#Pandas Selection Review

--
count:false

- `.loc[]`

--
count:false

- `.iloc[]`

--
count:false

- Fancy Indexing

--
count:false

- Slicing

--
count:false

- Boolean Mask

--
count:false

- Chaining

--
count:false

- `head` and `tail`

---
class:middle

# Questions re Pandas Selection?

---
#Data Exploration with Pandas
<br/>

Today, want to go over:

--
count:false

- reading in a csv

--
count:false

- getting information on a DataFrame

--
count:false

- getting summary statistics on a Numeric column

---
#Pandas: Reading in Data
<br/>

--
count:false

Pandas can handle many different data inputs:

--
count:false

```python
>>> pd.read_
pd.read_clipboard(  pd.read_html(       pd.read_sql(
pd.read_csv(        pd.read_json(       pd.read_sql_query(
pd.read_excel(      pd.read_msgpack(    pd.read_sql_table(
pd.read_feather(    pd.read_parquet(    pd.read_stata(
pd.read_fwf(        pd.read_pickle(     pd.read_table(
pd.read_gbq(        pd.read_sas(
pd.read_hdf(        pd.read_spss(
```

---
#Pandas: Reading in CSV
<br/>

`csv` is very common:
--
count:false
- one line per record
--
count:false
- columns separated by delimiter (usually comma), same number per row
--
count:false
- may include header row(s)

--
count:false

Example :

```csv
Index,Year,Class_Name,MeasureA
001,2017,A,2.1
002,2018,A,3.0
003,2018,B,2.4
004,2019,A,1.9
```

---
#Pandas: Reading in CSV Cont.
<br/>

--
count:false
```python
>>> df = pd.read_csv('../../data/example_dataframe.csv',
...                  index_col='Index')
```
--
count:false
```python
>>> df
       Year Class_Name  MeasureA
Index                           
1      2017          A       2.1
2      2018          A       3.0
3      2018          B       2.4
4      2019          A       1.9
```

---
#Get Summary Info on DataFrame

--
count:false

```python
*>>> df.info()
<class 'pandas.core.frame.DataFrame'>
Int64Index: 4 entries, 1 to 4
Data columns (total 3 columns):
Year          4 non-null int64
Class_Name    4 non-null object
MeasureA      4 non-null float64
dtypes: float64(1), int64(1), object(1)
memory usage: 128.0+ bytes

```

--
count:false
- number of rows (and index info)
--
count:false
- number of columns
--
count:false
- missing values
--
count:false
- column datatypes
--
count:false
- size in memory


---
#Get Summary Stats on Numeric Col

--
count:false

```python
*>>> df.MeasureA.describe()
count    4.000000
mean     2.350000
std      0.479583
min      1.900000
25%      2.050000
50%      2.250000
75%      2.550000
max      3.000000
Name: MeasureA, dtype: float64
```

--
count:false
- Count of non-null observations
--
count:false
- Mean
--
count:false
- Standard Deviation
--
count:false
- Min, Max And Quartiles

---
#Get Summary Stats on Non-Numeric

--
count:false

```python
>>> df.Class_Name.describe()
count     4
unique    2
top       A
freq      3
Name: Class_Name, dtype: object
```
--
count:false
- Count of non-null observations
--
count:false
- Number of unique values
--
count:false
- The most frequently seen value
--
count:false
- Frequency of the most frequently seen value

---
#Get Frequency Counts on a Column
<br/>

--
count:false

```python
>>> df.Class_Name.value_counts()
A    3
B    1
```

--
count:false

```python
>>> df.MeasureA.value_counts()
1.9    1
2.1    1
2.4    1
3.0    1
Name: MeasureA, dtype: int64
```

---
#Aside: Variable (Observation) Types

--
count:false
- **Numeric** (eg. weight, temperature)
    - usually has a zero value
    - describes magnitude
--
count:false
- **Categorical** (eg. class, variety)
    - usually a finite set
    - no order
--
count:false
- **Ordinal** (eg. Likert scale, education level, etc.)
    - usually a finite set
    - has order
    - usually missing zero
    - difference between levels may not be the same


--
count:false
- Might see others : interval, ratio, etc.




---
#Intro to Visualization in Python
<br/>

--
count:false
- Many libraries to do visualization

--
count:false

- We're going to use 3
    - matplotlib
    - pandas
    - seaborn

---
# What do we need to visualize?
<br/>

--
count:false

- relationships (line, scatter, ...)

--
count:false

- distributions (histogram, kde, scatter, box, violin, ...)

--
count:false

- comparisons (bar, box, violin, ...)

--
count:false

- more?

---
# Pandas built in plotting

`.plot`

--
count:false
```python
>>> df.plot.
df.plot.area(     df.plot.box(      df.plot.hist(     df.plot.pie(
df.plot.bar(      df.plot.density(  df.plot.kde(      df.plot.scatter(
df.plot.barh(     df.plot.hexbin(   df.plot.line(    
```

---
# Plot Frequency: Bar Chart
<br>

![](images/plotting_jupyter_1.png)


---
# Plot Frequency: Bar Chart

.center[
![:scale 60%](images/plotting_jupyter_2.png)]


---
# Plot Distribution: Histogram

![](images/plotting_jupyter_4.png)

---
# Plot Distribution: Histogram

![](images/plotting_jupyter_3.png)
---
class:middle

# Questions?


    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script>
    // Config Remark
    remark.macros['scale'] = function (percentage) {
        var url = this;
        return '<img src="' + url + '" style="width: ' + percentage + '" />';
    };
    config_remark = {
        highlightStyle: 'github',
        highlightSpans: true,
        highlightLines: true,
        ratio: "16:9"
    };
      var slideshow = remark.create(config_remark);

    // Configure MathJax
    MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] /* removed 'code' entry*/
    }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
    </script>
  </body>
</html>
